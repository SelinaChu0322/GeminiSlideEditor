<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智慧 PDF/OCR 簡報編輯器 (Clean Mode)</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <!-- Google Identity Services -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #e5e7eb; user-select: none; }
        
        .slide-preview { transition: all 0.2s; }
        .slide-preview:hover { border-color: #3b82f6; }
        .slide-preview.active { border-color: #2563eb; ring: 2px solid #2563eb; }
        
        /* 編輯區陰影與背景 */
        .editor-canvas {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            background-color: white;
            position: relative;
            overflow: hidden;
        }

        /* 可編輯文字框樣式 */
        .editable-box {
            position: absolute;
            outline: none;
            overflow: hidden; /* 直書時可能需要 visible，但為了不破版先 hidden */
            white-space: pre-wrap;
            z-index: 10;
            padding: 2px;
            line-height: 1.2;
            cursor: text;
            border: 1px solid transparent; 
            box-sizing: border-box;
            transition: border-color 0.1s;
        }
        
        .editable-box:hover {
            border: 1px solid #3b82f6;
            z-index: 15;
        }
        
        .editable-box.selected {
            border: 2px solid #2563eb; 
            z-index: 20;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* 直書支援 */
        .editable-box.vertical {
            writing-mode: vertical-rl;
            text-orientation: upright;
        }
        
        /* 屬性面板 */
        .property-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 260px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            z-index: 50;
            animation: slideIn 0.2s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/presentations https://www.googleapis.com/auth/cloud-vision';

        // --- 圖像處理工具: 計算區域周圍的平均顏色 (智慧去背用) ---
        const getDominantColor = (ctx, x, y, w, h) => {
            try {
                // 取樣邊框周圍的像素 (上、下、左、右各取樣一條線)
                // 為了效能，我們簡化為取樣四周擴大 2px 的範圍
                const margin = 2;
                const sx = Math.max(0, x - margin);
                const sy = Math.max(0, y - margin);
                const sw = w + margin * 2;
                const sh = h + margin * 2;
                
                const imgData = ctx.getImageData(sx, sy, sw, sh);
                const data = imgData.data;
                const colorCounts = {};
                let maxCount = 0;
                let dominant = 'rgb(255,255,255)';

                // 簡單統計 (每 4 個 bytes 為一組 RGBA)
                // 我們只統計邊緣，忽略中間 (因為中間是文字)
                for (let i = 0; i < data.length; i += 4 * 4) { // 跳躍取樣加速
                    const r = data[i];
                    const g = data[i+1];
                    const b = data[i+2];
                    const a = data[i+3];
                    
                    // 忽略透明
                    if (a < 50) continue;

                    // 簡單量化顏色以增加命中率 (每 10 為一階)
                    const key = `${Math.round(r/10)*10},${Math.round(g/10)*10},${Math.round(b/10)*10}`;
                    colorCounts[key] = (colorCounts[key] || 0) + 1;
                    
                    if (colorCounts[key] > maxCount) {
                        maxCount = colorCounts[key];
                        dominant = `rgb(${r},${g},${b})`;
                    }
                }
                return dominant;
            } catch (e) {
                return '#ffffff';
            }
        };

        // --- 可編輯文字方塊元件 ---
        const EditableBlock = React.memo(({ el, isSelected, onUpdate, onSelect }) => {
            const contentRef = useRef(null);

            useEffect(() => {
                if (contentRef.current && contentRef.current.innerText !== el.text) {
                    // 只有當此元件沒有焦點時，才從外部強制更新 (避免打字時游標跳動)
                    if (document.activeElement !== contentRef.current) {
                        contentRef.current.innerText = el.text;
                    }
                }
            }, [el.text]);

            const handleInput = (e) => {
                const newText = e.target.innerText;
                onUpdate(el.id, { text: newText });
            };

            const handleMouseDown = (e) => {
                e.stopPropagation(); 
                onSelect(el.id);
            };

            return (
                <div
                    ref={contentRef}
                    className={`editable-box ${isSelected ? 'selected' : ''} ${el.isVertical ? 'vertical' : ''}`}
                    contentEditable
                    suppressContentEditableWarning
                    style={{
                        left: `${el.x}px`,
                        top: `${el.y}px`,
                        width: `${el.width}px`,
                        height: `${el.height}px`,
                        fontSize: `${el.fontSize}px`,
                        color: el.color,
                        fontFamily: el.fontFamily,
                        backgroundColor: el.backgroundColor || 'transparent', // 如果底圖已去背，文字框可透明
                        textAlign: 'left'
                    }}
                    onInput={handleInput}
                    onMouseDown={handleMouseDown}
                >
                    {el.text}
                </div>
            );
        });

        function App() {
            // Config & Auth
            const [config, setConfig] = useState({ clientId: '', apiKey: '' });
            const [rememberConfig, setRememberConfig] = useState(true);
            const [isConfigured, setIsConfigured] = useState(false);
            const [tokenClient, setTokenClient] = useState(null);
            const [accessToken, setAccessToken] = useState(null);
            const [userProfile, setUserProfile] = useState(null);

            // Environment
            const [envError, setEnvError] = useState(null);
            const [currentOrigin, setCurrentOrigin] = useState('');
            const [isGithub, setIsGithub] = useState(false);

            // Editor
            const [slides, setSlides] = useState([]);
            const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
            const [scale, setScale] = useState(0.5);
            const [isProcessing, setIsProcessing] = useState(false);
            const [statusMsg, setStatusMsg] = useState('');
            
            // Selection
            const [selectedElementId, setSelectedElementId] = useState(null);
            const canvasContainerRef = useRef(null);

            // --- Initialization ---
            useEffect(() => {
                const protocol = window.location.protocol;
                const origin = window.location.origin;
                setCurrentOrigin(origin);
                if (protocol === 'file:') setEnvError('file_protocol');
                if (window.location.hostname.endsWith('github.io')) setIsGithub(true);

                const savedConfig = localStorage.getItem('slide_ocr_config');
                if (savedConfig) {
                    try {
                        const parsed = JSON.parse(savedConfig);
                        if (parsed.clientId) {
                            setConfig(parsed);
                            setIsConfigured(true);
                            initializeGoogle(parsed.clientId, parsed.apiKey);
                        }
                    } catch (e) { console.error(e); }
                }

                const handleGlobalClick = (e) => {
                    if (e.target.closest('.editable-box') || e.target.closest('.property-panel')) return;
                    setSelectedElementId(null);
                };
                window.addEventListener('mousedown', handleGlobalClick);
                return () => window.removeEventListener('mousedown', handleGlobalClick);
            }, []);

            const initializeGoogle = (clientId, apiKey) => {
                if (window.location.protocol === 'file:') return null;
                if (window.google && window.google.accounts) {
                    const client = google.accounts.oauth2.initTokenClient({
                        client_id: clientId, scope: SCOPES,
                        callback: (tokenResponse) => {
                            if (tokenResponse.access_token) {
                                setAccessToken(tokenResponse.access_token);
                                fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                                    headers: { Authorization: `Bearer ${tokenResponse.access_token}` }
                                }).then(res => res.json()).then(data => setUserProfile(data));
                            }
                        },
                        error_callback: (err) => alert("登入錯誤: " + JSON.stringify(err))
                    });
                    setTokenClient(client);
                }
                if (window.gapi) {
                    gapi.load('client', () => {
                        gapi.client.init({ apiKey: apiKey || undefined, discoveryDocs: ['https://slides.googleapis.com/$discovery/rest?version=v1', 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'] });
                    });
                }
            };

            const handleConfigSubmit = (e) => {
                e.preventDefault();
                if (envError) return;
                if (config.clientId) {
                    if (rememberConfig) localStorage.setItem('slide_ocr_config', JSON.stringify(config));
                    else localStorage.removeItem('slide_ocr_config');
                    setIsConfigured(true);
                    setTimeout(() => initializeGoogle(config.clientId, config.apiKey), 500);
                }
            };

            const clearConfig = () => {
                if (window.confirm("確定重設?")) {
                    localStorage.removeItem('slide_ocr_config');
                    window.location.reload();
                }
            };

            const handleLogin = () => {
                if (tokenClient) tokenClient.requestAccessToken();
                else {
                    const client = initializeGoogle(config.clientId, config.apiKey);
                    if(client) client.requestAccessToken();
                }
            };

            // --- File Upload ---
            const handleFileUpload = async (e) => {
                const files = Array.from(e.target.files);
                if (!files.length) return;
                setIsProcessing(true);
                let newSlides = [];
                for (const file of files) {
                    if (file.type === 'application/pdf') {
                        const ab = await file.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument(ab).promise;
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const vp = page.getViewport({ scale: 2.0 });
                            const cvs = document.createElement('canvas');
                            cvs.width = vp.width; cvs.height = vp.height;
                            await page.render({ canvasContext: cvs.getContext('2d'), viewport: vp }).promise;
                            newSlides.push({ id: crypto.randomUUID(), image: cvs.toDataURL('image/jpeg', 0.8), width: vp.width, height: vp.height, elements: [] });
                        }
                    } else if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        const imgData = await new Promise(r => { reader.onload = ev => r(ev.target.result); reader.readAsDataURL(file); });
                        const img = new Image();
                        await new Promise(r => { img.onload = r; img.src = imgData; });
                        newSlides.push({ id: crypto.randomUUID(), image: imgData, width: img.width, height: img.height, elements: [] });
                    }
                }
                setSlides(prev => [...prev, ...newSlides]);
                setIsProcessing(false);
            };

            // --- Advanced OCR & Text Removal ---
            const runOCR = async () => {
                if (!slides.length || !accessToken) return alert("請先登入並上傳檔案");
                const slide = slides[currentSlideIndex];
                if (slide.elements.length && !confirm("重新識別將會重置此頁面，確定嗎？")) return;
                
                setIsProcessing(true);
                setStatusMsg('OCR 分析中...');
                
                try {
                    // 1. Call Vision API
                    const res = await fetch(`https://vision.googleapis.com/v1/images:annotate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
                        body: JSON.stringify({ requests: [{ image: { content: slide.image.split(',')[1] }, features: [{ type: 'DOCUMENT_TEXT_DETECTION' }] }] })
                    });
                    const result = await res.json();
                    if (result.error) throw result.error;

                    // 2. Prepare Canvas for Image Manipulation (Removing text)
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = slide.width;
                    tempCanvas.height = slide.height;
                    const ctx = tempCanvas.getContext('2d');
                    
                    // Load current image to canvas
                    const img = new Image();
                    await new Promise(r => { img.onload = r; img.src = slide.image; });
                    ctx.drawImage(img, 0, 0);

                    const newElements = [];
                    const annotation = result.responses?.[0]?.fullTextAnnotation;
                    
                    if (annotation) {
                        setStatusMsg('正在智慧去除原圖文字...');
                        
                        annotation.pages[0].blocks.forEach(block => {
                            block.paragraphs.forEach(para => {
                                const vertices = para.boundingBox.vertices;
                                const text = para.words.map(w => w.symbols.map(s => s.text).join('')).join('');
                                
                                const x = vertices[0].x || 0;
                                const y = vertices[0].y || 0;
                                const w = (vertices[2].x || x) - x;
                                const h = (vertices[2].y || y) - y;

                                if (w > 0 && h > 0) {
                                    // A. 智慧取色 (Smart Background Sampling)
                                    const bgColor = getDominantColor(ctx, x, y, w, h);
                                    
                                    // B. 去除原圖文字 (Erasure by filling with background color)
                                    ctx.fillStyle = bgColor;
                                    ctx.fillRect(x - 1, y - 1, w + 2, h + 2); // 稍微擴大一點覆蓋範圍

                                    // C. 判斷直書 (Vertical Text Detection)
                                    // 簡單規則：如果高度 > 寬度 * 1.5 且包含非 ASCII 字元(可能是中文)，假定為直書
                                    const isVertical = (h > w * 1.5) && /[^\x00-\x7F]/.test(text);

                                    newElements.push({
                                        id: crypto.randomUUID(),
                                        text: text,
                                        x: x, y: y, width: w, height: h,
                                        // 字體大小微調
                                        fontSize: Math.round(isVertical ? w * 0.7 : h * 0.8),
                                        color: '#000000',
                                        fontFamily: 'Noto Sans TC',
                                        backgroundColor: bgColor, // 雖然底圖已去背，但為了無縫融合，這裡也設定同色背景
                                        isVertical: isVertical
                                    });
                                }
                            });
                        });
                    }
                    
                    // 3. Update Slide with "Cleaned" Image and New Elements
                    const updated = [...slides];
                    updated[currentSlideIndex].image = tempCanvas.toDataURL('image/jpeg', 0.9); // 更新為無字天書版底圖
                    updated[currentSlideIndex].elements = newElements;
                    setSlides(updated);

                } catch (err) { alert("OCR 失敗: " + (err.message || JSON.stringify(err))); }
                setIsProcessing(false); setStatusMsg('');
            };

            // --- Updates & Export ---
            const updateElement = useCallback((id, changes) => {
                setSlides(prev => {
                    const newSlides = [...prev];
                    const elements = newSlides[currentSlideIndex].elements;
                    const idx = elements.findIndex(e => e.id === id);
                    if (idx !== -1) {
                        elements[idx] = { ...elements[idx], ...changes };
                    }
                    return newSlides;
                });
            }, [currentSlideIndex]);

            const deleteElement = () => {
                if (!selectedElementId) return;
                setSlides(prev => {
                    const newSlides = [...prev];
                    newSlides[currentSlideIndex].elements = newSlides[currentSlideIndex].elements.filter(e => e.id !== selectedElementId);
                    return newSlides;
                });
                setSelectedElementId(null);
            };

            const exportToSlides = async () => {
                if (!accessToken) return alert("請先登入");
                setIsProcessing(true); setStatusMsg('建立簡報中...');
                try {
                    const createRes = await gapi.client.request({ path: 'https://slides.googleapis.com/v1/presentations', method: 'POST', body: { title: 'OCR Export' } });
                    const presentationId = createRes.result.presentationId;
                    let requests = [];

                    for (let i = 0; i < slides.length; i++) {
                        const s = slides[i];
                        const pageId = `slide_${i}_${Date.now()}`;
                        requests.push({ createSlide: { objectId: pageId, slideLayoutReference: { predefinedLayout: 'BLANK' } } });
                        
                        // Upload Cleaned BG
                        const boundary = '-------314159265358979323846';
                        const body = `\r\n--${boundary}\r\nContent-Type: application/json\r\n\r\n${JSON.stringify({name: 'bg.jpg', parents:['root']})}\r\n--${boundary}\r\nContent-Type: image/jpeg\r\nContent-Transfer-Encoding: base64\r\n\r\n${s.image.split(',')[1]}\r\n--${boundary}--`;
                        const upRes = await gapi.client.request({ path: '/upload/drive/v3/files?uploadType=multipart', method: 'POST', headers: { 'Content-Type': `multipart/related; boundary="${boundary}"` }, body: body });
                        const fileId = upRes.result.id;
                        await gapi.client.request({ path: `/drive/v3/files/${fileId}/permissions`, method: 'POST', body: { role: 'reader', type: 'anyone' } });

                        requests.push({ updatePageProperties: { objectId: pageId, pageProperties: { pageBackgroundFill: { stretchedPictureFill: { contentUrl: `https://drive.google.com/uc?export=download&id=${fileId}` } } }, fields: 'pageBackgroundFill' } });

                        // Add Text
                        const pxToPt = 0.75;
                        s.elements.forEach(el => {
                            const id = `txt_${el.id}`;
                            // 直書/橫書的 transform 稍微不同，但 Google Slides API 目前主要靠 Shape 內的文字設定
                            // 這裡我們主要設定位置和大小
                            requests.push({ 
                                createShape: { 
                                    objectId: id, 
                                    shapeType: 'TEXT_BOX', 
                                    elementProperties: { 
                                        pageObjectId: pageId, 
                                        size: { width: { magnitude: el.width * pxToPt, unit: 'PT' }, height: { magnitude: el.height * pxToPt, unit: 'PT' } }, 
                                        transform: { scaleX: 1, scaleY: 1, translateX: el.x * pxToPt, translateY: el.y * pxToPt, unit: 'PT' } 
                                    } 
                                } 
                            });
                            requests.push({ insertText: { objectId: id, text: el.text } });
                            
                            // Color Convert
                            const hex = el.color;
                            const r = parseInt(hex.slice(1,3),16)/255;
                            const g = parseInt(hex.slice(3,5),16)/255;
                            const b = parseInt(hex.slice(5,7),16)/255;

                            // 如果是直書，這裡暫時沒有簡單的 API 可以直接設 writingMode，
                            // 但我們可以先確保字型和顏色正確。Google Slides API 的 writingMode 設定較複雜。
                            requests.push({ 
                                updateTextStyle: { 
                                    objectId: id, 
                                    style: { 
                                        fontSize: { magnitude: el.fontSize * pxToPt, unit: 'PT' }, 
                                        foregroundColor: { opaqueColor: { rgbColor: { red: r, green: g, blue: b } } }, 
                                        fontFamily: el.fontFamily 
                                    }, 
                                    fields: 'fontSize,foregroundColor,fontFamily' 
                                } 
                            });
                        });
                    }
                    await gapi.client.request({ path: `https://slides.googleapis.com/v1/presentations/${presentationId}:batchUpdate`, method: 'POST', body: { requests } });
                    window.open(`https://docs.google.com/presentation/d/${presentationId}/edit`, '_blank');
                } catch (e) { alert("匯出失敗: " + (e.result?.error?.message || e.message)); }
                setIsProcessing(false); setStatusMsg('');
            };

            const currentSlide = slides[currentSlideIndex];

            if (!isConfigured) return (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="bg-white p-8 rounded shadow-lg max-w-md w-full">
                        <h1 className="text-2xl font-bold mb-4 text-blue-600">設定 Google Cloud</h1>
                        {envError && <div className="text-red-600 bg-red-50 p-3 rounded mb-4 text-sm font-bold">請勿直接開啟 HTML (file://)，請使用 Local Server。</div>}
                        {!envError && <div className="bg-blue-50 p-3 rounded mb-4 text-xs text-blue-800">請將此網址加入 GCP Console 的「已授權來源」：<br/><code className="select-all bg-white p-1 rounded border">{currentOrigin}</code></div>}
                        <form onSubmit={handleConfigSubmit}>
                            <input required className="w-full border p-2 rounded mb-4" value={config.clientId} onChange={e=>setConfig({...config, clientId: e.target.value})} placeholder="Client ID" />
                            <input className="w-full border p-2 rounded mb-4" value={config.apiKey} onChange={e=>setConfig({...config, apiKey: e.target.value})} placeholder="API Key (選填)" />
                            <label className="flex items-center mb-6"><input type="checkbox" checked={rememberConfig} onChange={e=>setRememberConfig(e.target.checked)} className="mr-2"/> 記住設定</label>
                            <button disabled={!!envError} className="w-full bg-blue-600 text-white p-2 rounded font-bold hover:bg-blue-700">儲存並登入</button>
                        </form>
                    </div>
                </div>
            );

            return (
                <div className="flex flex-col h-screen overflow-hidden">
                    <header className="bg-white border-b px-4 py-2 flex justify-between items-center z-20 shadow-sm">
                        <div className="flex items-center gap-2 font-bold text-lg text-gray-700"><i className="fas fa-file-powerpoint text-yellow-500"></i> OCR Slide Editor</div>
                        <div className="flex items-center gap-3">
                            {isProcessing && <div className="loader w-5 h-5"></div>}
                            <span className="text-sm text-gray-500">{statusMsg}</span>
                            {!accessToken ? <button onClick={handleLogin} className="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700">登入</button> : 
                            <div className="flex items-center gap-2">
                                {userProfile && <img src={userProfile.picture} className="w-8 h-8 rounded-full border"/>}
                                <button onClick={exportToSlides} className="bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600 shadow-sm">匯出 PPT</button>
                                <button onClick={clearConfig} className="text-gray-400 hover:text-red-500"><i className="fas fa-sign-out-alt"></i></button>
                            </div>}
                        </div>
                    </header>

                    <div className="bg-white border-b px-4 py-2 flex items-center gap-4 text-sm shadow-sm z-10">
                        <label className="cursor-pointer hover:bg-gray-100 px-2 py-1 rounded border"><i className="fas fa-upload mr-1"></i> 上傳<input type="file" multiple accept=".pdf,image/*" className="hidden" onChange={handleFileUpload} /></label>
                        <button onClick={runOCR} disabled={!currentSlide || isProcessing} className="hover:bg-purple-50 text-purple-700 px-2 py-1 rounded border disabled:opacity-50"><i className="fas fa-magic mr-1"></i> OCR 智慧去字轉換</button>
                        <div className="ml-auto flex items-center gap-2">
                            <button onClick={() => setScale(s => Math.max(0.1, s - 0.1))} className="w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded">-</button>
                            <span>{Math.round(scale * 100)}%</span>
                            <button onClick={() => setScale(s => Math.min(3, s + 0.1))} className="w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded">+</button>
                        </div>
                    </div>

                    <div className="flex flex-1 overflow-hidden relative">
                        {/* 左側縮圖 */}
                        <div className="w-48 bg-gray-50 border-r flex-shrink-0 overflow-y-auto p-2 flex flex-col gap-2 z-10">
                            {slides.map((s, idx) => (
                                <div key={s.id} onClick={() => setCurrentSlideIndex(idx)} className={`slide-preview cursor-pointer bg-white border-2 rounded p-1 ${currentSlideIndex === idx ? 'active' : 'border-transparent'}`}>
                                    <img src={s.image} className="w-full h-auto object-contain" />
                                    <div className="text-center text-xs text-gray-500 mt-1">{idx + 1}</div>
                                </div>
                            ))}
                        </div>

                        {/* 主編輯區 */}
                        <div className="flex-1 bg-gray-200 overflow-auto flex justify-center p-10" ref={canvasContainerRef}>
                            {currentSlide ? (
                                <div style={{ width: currentSlide.width * scale, height: currentSlide.height * scale, flexShrink: 0 }}>
                                    <div className="editor-canvas" style={{ width: currentSlide.width, height: currentSlide.height, transform: `scale(${scale})`, transformOrigin: 'top left' }}>
                                        <img src={currentSlide.image} className="absolute inset-0 w-full h-full pointer-events-none" />
                                        {currentSlide.elements.map(el => (
                                            <EditableBlock 
                                                key={el.id} 
                                                el={el} 
                                                isSelected={selectedElementId === el.id} 
                                                onSelect={setSelectedElementId} 
                                                onUpdate={updateElement} 
                                            />
                                        ))}
                                    </div>
                                </div>
                            ) : <div className="m-auto text-gray-400 text-center"><i className="fas fa-image text-4xl mb-2"></i><br/>請上傳文件</div>}
                        </div>

                        {/* 懸浮屬性面板 */}
                        {selectedElementId && (
                            <div className="property-panel p-4 flex flex-col gap-3" onMouseDown={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center border-b pb-2 mb-1">
                                    <h3 className="font-bold text-gray-700">文字樣式</h3>
                                    <button onClick={deleteElement} className="text-red-500 hover:bg-red-50 px-2 py-1 rounded text-xs"><i className="fas fa-trash-alt"></i> 刪除</button>
                                </div>
                                {(() => {
                                    const el = currentSlide.elements.find(e => e.id === selectedElementId);
                                    if (!el) return null;
                                    return (
                                        <>
                                            <div className="grid grid-cols-2 gap-2">
                                                <div>
                                                    <label className="text-xs text-gray-500">字型大小</label>
                                                    <input type="number" value={Math.round(el.fontSize)} onChange={(e) => updateElement(el.id, { fontSize: parseInt(e.target.value) })} className="w-full border rounded p-1" />
                                                </div>
                                                <div>
                                                    <label className="text-xs text-gray-500">顏色</label>
                                                    <input type="color" value={el.color} onChange={(e) => updateElement(el.id, { color: e.target.value })} className="w-full h-8 cursor-pointer border rounded" />
                                                </div>
                                            </div>
                                            <div>
                                                <label className="text-xs text-gray-500 block mb-1">背景色</label>
                                                <div className="flex gap-2">
                                                    <input type="color" value={el.backgroundColor || '#ffffff'} onChange={(e) => updateElement(el.id, { backgroundColor: e.target.value })} className="flex-1 h-8 cursor-pointer border rounded" />
                                                    <button onClick={() => updateElement(el.id, { backgroundColor: 'transparent' })} className="text-xs bg-gray-100 px-2 rounded border">透明</button>
                                                </div>
                                            </div>
                                            <div className="flex items-center gap-2 mt-1">
                                                <input type="checkbox" checked={el.isVertical || false} onChange={(e) => updateElement(el.id, { isVertical: e.target.checked })} />
                                                <label className="text-xs text-gray-700">直書模式 (Vertical)</label>
                                            </div>
                                            <div>
                                                <label className="text-xs text-gray-500">字型</label>
                                                <select value={el.fontFamily} onChange={(e) => updateElement(el.id, { fontFamily: e.target.value })} className="w-full border rounded p-1 text-sm">
                                                    <option value="Noto Sans TC">Noto Sans TC</option>
                                                    <option value="Arial">Arial</option>
                                                    <option value="Times New Roman">Times New Roman</option>
                                                    <option value="Microsoft JhengHei">微軟正黑體</option>
                                                </select>
                                            </div>
                                        </>
                                    );
                                })()}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>