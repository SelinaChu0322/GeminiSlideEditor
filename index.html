<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºæ…§ PDF/OCR ç°¡å ±ç·¨è¼¯å™¨ (Hybrid Clean Mode)</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <!-- Google Identity Services -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #e5e7eb; user-select: none; }
        
        .slide-preview { transition: all 0.2s; }
        .slide-preview:hover { border-color: #3b82f6; }
        .slide-preview.active { border-color: #2563eb; ring: 2px solid #2563eb; }
        
        .editor-canvas {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            background-color: white;
            position: relative;
            overflow: hidden;
        }

        .editable-box {
            position: absolute;
            outline: none;
            overflow: hidden;
            white-space: pre-wrap;
            z-index: 10;
            padding: 2px;
            line-height: 1.2;
            cursor: text;
            border: 1px solid transparent; 
            box-sizing: border-box;
            transition: border-color 0.1s;
        }
        
        .editable-box:hover {
            border: 1px solid #3b82f6;
            z-index: 15;
        }
        
        .editable-box.selected {
            border: 2px solid #2563eb; 
            z-index: 20;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .editable-box.vertical {
            writing-mode: vertical-rl;
            text-orientation: upright;
        }
        
        .property-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 260px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            z-index: 50;
            animation: slideIn 0.2s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        /* ä¾¿åˆ©è²¼æ¨£å¼ */
        .sticky-note {
            background-color: #fef3c7; /* yellow-100 */
            border-left: 4px solid #f59e0b; /* yellow-500 */
            padding: 1rem;
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border-radius: 0.375rem;
            font-size: 0.875rem;
            color: #78350f; /* yellow-900 */
            max-width: 320px;
            animation: fadeIn 0.5s ease-out;
        }
        
        .sticky-note .close-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            color: #92400e;
            cursor: pointer;
            opacity: 0.6;
        }
        .sticky-note .close-btn:hover { opacity: 1; }

        .help-btn {
            cursor: pointer;
            color: #3b82f6;
            margin-left: 6px;
            font-size: 0.9em;
            transition: color 0.2s;
        }
        .help-btn:hover { color: #2563eb; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/presentations https://www.googleapis.com/auth/cloud-vision';

        // --- å„ªåŒ–ç‰ˆæ¼”ç®—æ³•: æ··åˆå¡«è‰²ä¿®å¾© (Hybrid Inpainting) ---
        // è‡ªå‹•åˆ¤æ–·å€åŸŸæ˜¯ã€Œç´”è‰²ã€é‚„æ˜¯ã€Œæ¼¸å±¤ã€ï¼Œé¸æ“‡æœ€ä½³å¡«è£œæ–¹å¼
        const smartInpaint = (ctx, x, y, w, h) => {
            try {
                const margin = 2; // å–æ¨£ç¯„åœ
                const sx = Math.max(0, Math.floor(x - margin));
                const sy = Math.max(0, Math.floor(y - margin));
                const sw = Math.ceil(w + margin * 2);
                const sh = Math.ceil(h + margin * 2);

                const imgData = ctx.getImageData(sx, sy, sw, sh);
                const data = imgData.data;
                const width = sw;
                const height = sh;

                // 1. åˆ†æé‚Šç•Œé¡è‰²è®Šç•°æ•¸ (Variance)
                let rSum = 0, gSum = 0, bSum = 0;
                let count = 0;
                const borderPixels = [];

                // æ”¶é›†é‚Šç•Œåƒç´ 
                const addPixel = (idx) => {
                    const r = data[idx], g = data[idx+1], b = data[idx+2];
                    rSum += r; gSum += g; bSum += b;
                    borderPixels.push({r, g, b});
                    count++;
                };

                for (let i = 0; i < width; i++) {
                    addPixel((0 * width + i) * 4); // Top
                    addPixel(((height - 1) * width + i) * 4); // Bottom
                }
                for (let j = 1; j < height - 1; j++) {
                    addPixel((j * width + 0) * 4); // Left
                    addPixel((j * width + (width - 1)) * 4); // Right
                }

                const rAvg = rSum / count;
                const gAvg = gSum / count;
                const bAvg = bSum / count;

                // è¨ˆç®—æ¨™æº–å·®
                let variance = 0;
                borderPixels.forEach(p => {
                    variance += Math.pow(p.r - rAvg, 2) + Math.pow(p.g - gAvg, 2) + Math.pow(p.b - bAvg, 2);
                });
                variance /= count;
                const stdDev = Math.sqrt(variance);

                // 2. æ±ºç­–ï¼šå¦‚æœæ˜¯ä½è®Šç•° (ç´”è‰²èƒŒæ™¯)ï¼Œç›´æ¥å¡«å¹³å‡è‰²ï¼›å¦‚æœæ˜¯é«˜è®Šç•°ï¼Œç”¨æ’å€¼
                const THRESHOLD = 30; // é–¾å€¼ï¼Œå¯èª¿æ•´
                
                if (stdDev < THRESHOLD) {
                    // --- æ¨¡å¼ A: ç´”è‰²å¡«æ»¿ (Solid Fill) ---
                    // é€™å°æ–¼ç™½åº•é»‘å­—çš„æ–‡ä»¶æ•ˆæœæœ€å¥½ï¼Œä¸æœƒæœ‰æ¨¡ç³Šæ„Ÿ
                    for (let j = margin; j < height - margin; j++) {
                        for (let i = margin; i < width - margin; i++) {
                            const index = (j * width + i) * 4;
                            data[index] = rAvg;
                            data[index+1] = gAvg;
                            data[index+2] = bAvg;
                            data[index+3] = 255;
                        }
                    }
                } else {
                    // --- æ¨¡å¼ B: é›™ç·šæ€§æ’å€¼ (Bilinear Interpolation) ---
                    // é©åˆæ¼¸å±¤èƒŒæ™¯æˆ–è¤‡é›œåœ–æ¡ˆ
                    for (let j = margin; j < height - margin; j++) {
                        for (let i = margin; i < width - margin; i++) {
                            const index = (j * width + i) * 4;
                            
                            const topIdx = (0 * width + i) * 4;
                            const bottomIdx = ((height - 1) * width + i) * 4;
                            const leftIdx = (j * width + 0) * 4;
                            const rightIdx = (j * width + (width - 1)) * 4;

                            const yRatio = j / height;
                            const xRatio = i / width;

                            // æ··åˆæ¬Šé‡è¨ˆç®—
                            const rH = data[topIdx] * (1 - yRatio) + data[bottomIdx] * yRatio;
                            const rV = data[leftIdx] * (1 - xRatio) + data[rightIdx] * xRatio;
                            data[index] = (rH + rV) / 2;

                            const gH = data[topIdx+1] * (1 - yRatio) + data[bottomIdx+1] * yRatio;
                            const gV = data[leftIdx+1] * (1 - xRatio) + data[rightIdx+1] * xRatio;
                            data[index+1] = (gH + gV) / 2;

                            const bH = data[topIdx+2] * (1 - yRatio) + data[bottomIdx+2] * yRatio;
                            const bV = data[leftIdx+2] * (1 - xRatio) + data[rightIdx+2] * xRatio;
                            data[index+2] = (bH + bV) / 2;

                            data[index+3] = 255;
                        }
                    }
                }
                
                ctx.putImageData(imgData, sx, sy);
            } catch (e) {
                console.error("Inpainting failed", e);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y, w, h);
            }
        };

        const EditableBlock = React.memo(({ el, isSelected, onUpdate, onSelect }) => {
            const contentRef = useRef(null);

            useEffect(() => {
                if (contentRef.current && contentRef.current.innerText !== el.text) {
                    if (document.activeElement !== contentRef.current) {
                        contentRef.current.innerText = el.text;
                    }
                }
            }, [el.text]);

            const handleInput = (e) => {
                const newText = e.target.innerText;
                onUpdate(el.id, { text: newText });
            };

            const handleMouseDown = (e) => {
                e.stopPropagation(); 
                onSelect(el.id);
            };

            return (
                <div
                    ref={contentRef}
                    className={`editable-box ${isSelected ? 'selected' : ''} ${el.isVertical ? 'vertical' : ''}`}
                    contentEditable
                    suppressContentEditableWarning
                    style={{
                        left: `${el.x}px`,
                        top: `${el.y}px`,
                        width: `${el.width}px`,
                        height: `${el.height}px`,
                        fontSize: `${el.fontSize}px`,
                        color: el.color,
                        fontFamily: el.fontFamily,
                        backgroundColor: el.backgroundColor || 'transparent', 
                        textAlign: 'left'
                    }}
                    onInput={handleInput}
                    onMouseDown={handleMouseDown}
                >
                    {el.text}
                </div>
            );
        });

        // --- ä¾¿åˆ©è²¼å…ƒä»¶ ---
        const HelpNote = ({ title, onClose, children }) => (
            <div className="sticky-note mb-4">
                <div className="close-btn" onClick={onClose}><i className="fas fa-times"></i></div>
                <h4 className="font-bold mb-2 text-amber-800 border-b border-amber-300 pb-1">{title}</h4>
                <div className="space-y-1">
                    {children}
                </div>
            </div>
        );

        function App() {
            const [config, setConfig] = useState({ clientId: '', apiKey: '' });
            const [rememberConfig, setRememberConfig] = useState(true);
            const [isConfigured, setIsConfigured] = useState(false);
            const [tokenClient, setTokenClient] = useState(null);
            const [accessToken, setAccessToken] = useState(null);
            const [userProfile, setUserProfile] = useState(null);
            const [envError, setEnvError] = useState(null);
            const [currentOrigin, setCurrentOrigin] = useState('');
            const [isGithub, setIsGithub] = useState(false);
            
            // UI State
            const [showIdHelp, setShowIdHelp] = useState(true);
            const [showOriginHelp, setShowOriginHelp] = useState(true);

            // Editor
            const [slides, setSlides] = useState([]);
            const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
            const [scale, setScale] = useState(0.5);
            const [isProcessing, setIsProcessing] = useState(false);
            const [statusMsg, setStatusMsg] = useState('');
            const [selectedElementId, setSelectedElementId] = useState(null);
            const canvasContainerRef = useRef(null);

            useEffect(() => {
                const protocol = window.location.protocol;
                const origin = window.location.origin;
                setCurrentOrigin(origin);
                if (protocol === 'file:') setEnvError('file_protocol');
                if (window.location.hostname.endsWith('github.io')) setIsGithub(true);

                // 1. æ¢å¾© Client ID è¨­å®š
                const savedConfig = localStorage.getItem('slide_ocr_config');
                if (savedConfig) {
                    try {
                        const parsed = JSON.parse(savedConfig);
                        if (parsed.clientId) {
                            setConfig(parsed);
                            setIsConfigured(true);
                            initializeGoogle(parsed.clientId, parsed.apiKey);
                        }
                    } catch (e) { console.error(e); }
                }

                // 2. æ¢å¾©ç™»å…¥ç‹€æ…‹ (æª¢æŸ¥ Token æœ‰æ•ˆæ€§)
                const savedAuth = localStorage.getItem('slide_ocr_auth');
                if (savedAuth) {
                    try {
                        const authData = JSON.parse(savedAuth);
                        if (authData.token && authData.expiry > Date.now() + 300000) {
                            console.log("Restoring active session...");
                            setAccessToken(authData.token);
                            fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                                headers: { Authorization: `Bearer ${authData.token}` }
                            }).then(res => {
                                if (!res.ok) throw new Error('Token expired');
                                return res.json();
                            }).then(data => {
                                setUserProfile(data);
                            }).catch(err => {
                                console.warn("Session restore failed", err);
                                setAccessToken(null);
                                localStorage.removeItem('slide_ocr_auth');
                            });
                        } else {
                            localStorage.removeItem('slide_ocr_auth');
                        }
                    } catch (e) {
                        localStorage.removeItem('slide_ocr_auth');
                    }
                }

                const handleGlobalClick = (e) => {
                    if (e.target.closest('.editable-box') || e.target.closest('.property-panel')) return;
                    setSelectedElementId(null);
                };
                window.addEventListener('mousedown', handleGlobalClick);
                return () => window.removeEventListener('mousedown', handleGlobalClick);
            }, []);

            const initializeGoogle = (clientId, apiKey) => {
                if (window.location.protocol === 'file:') return null;
                if (window.google && window.google.accounts) {
                    const client = google.accounts.oauth2.initTokenClient({
                        client_id: clientId, scope: SCOPES,
                        callback: (tokenResponse) => {
                            if (tokenResponse.access_token) {
                                setAccessToken(tokenResponse.access_token);
                                
                                const expiryTime = Date.now() + (tokenResponse.expires_in * 1000);
                                localStorage.setItem('slide_ocr_auth', JSON.stringify({
                                    token: tokenResponse.access_token,
                                    expiry: expiryTime
                                }));

                                fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                                    headers: { Authorization: `Bearer ${tokenResponse.access_token}` }
                                }).then(res => res.json()).then(data => setUserProfile(data));
                            }
                        },
                        error_callback: (err) => alert("ç™»å…¥éŒ¯èª¤: " + JSON.stringify(err))
                    });
                    setTokenClient(client);
                }
                if (window.gapi) {
                    gapi.load('client', () => {
                        gapi.client.init({ apiKey: apiKey || undefined, discoveryDocs: ['https://slides.googleapis.com/$discovery/rest?version=v1', 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'] });
                    });
                }
            };

            const handleConfigSubmit = (e) => {
                e.preventDefault();
                if (envError) return;
                if (config.clientId) {
                    if (rememberConfig) localStorage.setItem('slide_ocr_config', JSON.stringify(config));
                    else localStorage.removeItem('slide_ocr_config');
                    setIsConfigured(true);
                    
                    setTimeout(() => {
                        const client = initializeGoogle(config.clientId, config.apiKey);
                        if (client && !accessToken) {
                            client.requestAccessToken();
                        }
                    }, 500);
                }
            };

            const clearConfig = () => {
                if (window.confirm("ç¢ºå®šé‡è¨­? é€™å°‡æ¸…é™¤ç™»å…¥ç‹€æ…‹èˆ‡ Client IDã€‚")) {
                    localStorage.removeItem('slide_ocr_config');
                    localStorage.removeItem('slide_ocr_auth');
                    window.location.reload();
                }
            };

            const handleLogin = () => {
                if (tokenClient) tokenClient.requestAccessToken();
                else {
                    const client = initializeGoogle(config.clientId, config.apiKey);
                    if(client) client.requestAccessToken();
                }
            };

            const handleFileUpload = async (e) => {
                const files = Array.from(e.target.files);
                if (!files.length) return;
                setIsProcessing(true);
                let newSlides = [];
                for (const file of files) {
                    if (file.type === 'application/pdf') {
                        const ab = await file.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument(ab).promise;
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const vp = page.getViewport({ scale: 2.0 });
                            const cvs = document.createElement('canvas');
                            cvs.width = vp.width; cvs.height = vp.height;
                            await page.render({ canvasContext: cvs.getContext('2d'), viewport: vp }).promise;
                            newSlides.push({ id: crypto.randomUUID(), image: cvs.toDataURL('image/jpeg', 0.8), width: vp.width, height: vp.height, elements: [] });
                        }
                    } else if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        const imgData = await new Promise(r => { reader.onload = ev => r(ev.target.result); reader.readAsDataURL(file); });
                        const img = new Image();
                        await new Promise(r => { img.onload = r; img.src = imgData; });
                        newSlides.push({ id: crypto.randomUUID(), image: imgData, width: img.width, height: img.height, elements: [] });
                    }
                }
                setSlides(prev => [...prev, ...newSlides]);
                setIsProcessing(false);
            };

            const runOCR = async () => {
                if (!slides.length || !accessToken) return alert("è«‹å…ˆç™»å…¥ä¸¦ä¸Šå‚³æª”æ¡ˆ");
                const slide = slides[currentSlideIndex];
                if (slide.elements.length && !confirm("é‡æ–°è­˜åˆ¥å°‡æœƒé‡ç½®æ­¤é é¢ï¼Œç¢ºå®šå—ï¼Ÿ")) return;
                
                setIsProcessing(true);
                setStatusMsg('OCR åˆ†æä¸­...');
                
                try {
                    const res = await fetch(`https://vision.googleapis.com/v1/images:annotate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
                        body: JSON.stringify({ requests: [{ image: { content: slide.image.split(',')[1] }, features: [{ type: 'DOCUMENT_TEXT_DETECTION' }] }] })
                    });
                    const result = await res.json();
                    if (result.error) throw result.error;

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = slide.width;
                    tempCanvas.height = slide.height;
                    const ctx = tempCanvas.getContext('2d');
                    const img = new Image();
                    await new Promise(r => { img.onload = r; img.src = slide.image; });
                    ctx.drawImage(img, 0, 0);

                    const newElements = [];
                    const annotation = result.responses?.[0]?.fullTextAnnotation;
                    
                    if (annotation) {
                        setStatusMsg('æ­£åœ¨åŸ·è¡Œæ™ºæ…§å»èƒŒèˆ‡æ–‡å­—å¡«è£œ...');
                        
                        annotation.pages[0].blocks.forEach(block => {
                            block.paragraphs.forEach(para => {
                                const vertices = para.boundingBox.vertices;
                                const text = para.words.map(w => w.symbols.map(s => s.text).join('')).join('');
                                
                                const x = vertices[0].x || 0;
                                const y = vertices[0].y || 0;
                                const w = (vertices[2].x || x) - x;
                                const h = (vertices[2].y || y) - y;

                                if (w > 0 && h > 0) {
                                    smartInpaint(ctx, x, y, w, h);

                                    const isVertical = (h > w * 1.5) && /[^\x00-\x7F]/.test(text);

                                    newElements.push({
                                        id: crypto.randomUUID(),
                                        text: text,
                                        x: x, y: y, width: w, height: h,
                                        fontSize: Math.round(isVertical ? w * 0.7 : h * 0.8),
                                        color: '#000000',
                                        fontFamily: 'Noto Sans TC',
                                        backgroundColor: 'transparent',
                                        isVertical: isVertical
                                    });
                                }
                            });
                        });
                    }
                    
                    const updated = [...slides];
                    updated[currentSlideIndex].image = tempCanvas.toDataURL('image/jpeg', 0.9);
                    updated[currentSlideIndex].elements = newElements;
                    setSlides(updated);

                } catch (err) { alert("OCR å¤±æ•—: " + (err.message || JSON.stringify(err))); }
                setIsProcessing(false); setStatusMsg('');
            };

            const updateElement = useCallback((id, changes) => {
                setSlides(prev => {
                    const newSlides = [...prev];
                    const elements = newSlides[currentSlideIndex].elements;
                    const idx = elements.findIndex(e => e.id === id);
                    if (idx !== -1) {
                        elements[idx] = { ...elements[idx], ...changes };
                    }
                    return newSlides;
                });
            }, [currentSlideIndex]);

            const deleteElement = () => {
                if (!selectedElementId) return;
                setSlides(prev => {
                    const newSlides = [...prev];
                    newSlides[currentSlideIndex].elements = newSlides[currentSlideIndex].elements.filter(e => e.id !== selectedElementId);
                    return newSlides;
                });
                setSelectedElementId(null);
            };

            const exportToSlides = async () => {
                if (!accessToken) return alert("è«‹å…ˆç™»å…¥");
                setIsProcessing(true); setStatusMsg('å»ºç«‹ç°¡å ±ä¸­...');
                try {
                    const createRes = await gapi.client.request({ path: 'https://slides.googleapis.com/v1/presentations', method: 'POST', body: { title: 'OCR Export' } });
                    const presentationId = createRes.result.presentationId;
                    let requests = [];

                    for (let i = 0; i < slides.length; i++) {
                        const s = slides[i];
                        const pageId = `slide_${i}_${Date.now()}`;
                        requests.push({ createSlide: { objectId: pageId, slideLayoutReference: { predefinedLayout: 'BLANK' } } });
                        
                        const boundary = '-------314159265358979323846';
                        const body = `\r\n--${boundary}\r\nContent-Type: application/json\r\n\r\n${JSON.stringify({name: 'bg.jpg', parents:['root']})}\r\n--${boundary}\r\nContent-Type: image/jpeg\r\nContent-Transfer-Encoding: base64\r\n\r\n${s.image.split(',')[1]}\r\n--${boundary}--`;
                        const upRes = await gapi.client.request({ path: '/upload/drive/v3/files?uploadType=multipart', method: 'POST', headers: { 'Content-Type': `multipart/related; boundary="${boundary}"` }, body: body });
                        const fileId = upRes.result.id;
                        await gapi.client.request({ path: `/drive/v3/files/${fileId}/permissions`, method: 'POST', body: { role: 'reader', type: 'anyone' } });

                        requests.push({ updatePageProperties: { objectId: pageId, pageProperties: { pageBackgroundFill: { stretchedPictureFill: { contentUrl: `https://drive.google.com/uc?export=download&id=${fileId}` } } }, fields: 'pageBackgroundFill' } });

                        const pxToPt = 0.75;
                        s.elements.forEach(el => {
                            const id = `txt_${el.id}`;
                            requests.push({ 
                                createShape: { 
                                    objectId: id, 
                                    shapeType: 'TEXT_BOX', 
                                    elementProperties: { 
                                        pageObjectId: pageId, 
                                        size: { width: { magnitude: el.width * pxToPt, unit: 'PT' }, height: { magnitude: el.height * pxToPt, unit: 'PT' } }, 
                                        transform: { scaleX: 1, scaleY: 1, translateX: el.x * pxToPt, translateY: el.y * pxToPt, unit: 'PT' } 
                                    } 
                                } 
                            });
                            requests.push({ insertText: { objectId: id, text: el.text } });
                            
                            const hex = el.color;
                            const r = parseInt(hex.slice(1,3),16)/255;
                            const g = parseInt(hex.slice(3,5),16)/255;
                            const b = parseInt(hex.slice(5,7),16)/255;

                            requests.push({ 
                                updateTextStyle: { 
                                    objectId: id, 
                                    style: { 
                                        fontSize: { magnitude: el.fontSize * pxToPt, unit: 'PT' }, 
                                        foregroundColor: { opaqueColor: { rgbColor: { red: r, green: g, blue: b } } }, 
                                        fontFamily: el.fontFamily 
                                    }, 
                                    fields: 'fontSize,foregroundColor,fontFamily' 
                                } 
                            });
                        });
                    }
                    await gapi.client.request({ path: `https://slides.googleapis.com/v1/presentations/${presentationId}:batchUpdate`, method: 'POST', body: { requests } });
                    window.open(`https://docs.google.com/presentation/d/${presentationId}/edit`, '_blank');
                } catch (e) { alert("åŒ¯å‡ºå¤±æ•—: " + (e.result?.error?.message || e.message)); }
                setIsProcessing(false); setStatusMsg('');
            };

            const currentSlide = slides[currentSlideIndex];

            if (!isConfigured) return (
                <div className="min-h-screen flex flex-col md:flex-row items-center justify-center p-4 gap-8">
                    {/* å·¦å´ï¼šè¨­å®š/ç™»å…¥è¡¨å–® */}
                    <div className="bg-white p-8 rounded shadow-lg max-w-md w-full flex-shrink-0">
                        <h1 className="text-2xl font-bold mb-4 text-blue-600">è¨­å®š Google Cloud</h1>
                        {envError && <div className="text-red-600 bg-red-50 p-3 rounded mb-4 text-sm font-bold">è«‹å‹¿ç›´æ¥é–‹å•Ÿ HTML (file://)ï¼Œè«‹ä½¿ç”¨ Local Serverã€‚</div>}
                        {!envError && <div className="bg-blue-50 p-3 rounded mb-4 text-xs text-blue-800 flex justify-between items-start">
                            <div className="flex-1 mr-2">
                                è«‹å°‡æ­¤ç¶²å€åŠ å…¥ GCP Console çš„ã€Œå·²æˆæ¬Šä¾†æºã€ï¼š<br/>
                                <div className="flex items-center gap-1 mt-1">
                                    <code className="select-all bg-white p-1 rounded border break-all flex-1">{currentOrigin}</code>
                                    <button 
                                        onClick={() => navigator.clipboard.writeText(currentOrigin).then(()=>alert("å·²è¤‡è£½ç¶²å€ï¼"))} 
                                        className="text-blue-600 hover:text-blue-800 bg-white border px-2 py-1 rounded hover:bg-gray-50 transition-colors"
                                        title="è¤‡è£½ç¶²å€"
                                    >
                                        <i className="far fa-copy"></i>
                                    </button>
                                </div>
                            </div>
                            <i className="fas fa-question-circle help-btn mt-1" onClick={() => setShowOriginHelp(true)} title="é¡¯ç¤ºèªªæ˜"></i>
                        </div>}
                        <form onSubmit={handleConfigSubmit}>
                            <div className="mb-4">
                                <label className="block text-sm font-medium text-gray-700 mb-1 flex items-center">
                                    Client ID (å¿…è¦)
                                    <i className="fas fa-question-circle help-btn" onClick={() => setShowIdHelp(true)} title="å¦‚ä½•å–å¾—?"></i>
                                </label>
                                <input required className="w-full border p-2 rounded" value={config.clientId} onChange={e=>setConfig({...config, clientId: e.target.value})} placeholder="xxx.apps.googleusercontent.com" />
                            </div>
                            <input className="w-full border p-2 rounded mb-4" value={config.apiKey} onChange={e=>setConfig({...config, apiKey: e.target.value})} placeholder="API Key (é¸å¡«)" />
                            <label className="flex items-center mb-6"><input type="checkbox" checked={rememberConfig} onChange={e=>setRememberConfig(e.target.checked)} className="mr-2"/> è¨˜ä½è¨­å®š</label>
                            <button disabled={!!envError} className="w-full bg-blue-600 text-white p-2 rounded font-bold hover:bg-blue-700 shadow flex items-center justify-center gap-2">
                                <span>å„²å­˜ä¸¦ç™»å…¥ Google</span>
                                <i className="fab fa-google"></i>
                            </button>
                        </form>
                    </div>

                    {/* å³å´ï¼šæ•™å­¸ä¾¿åˆ©è²¼å€å¡Š */}
                    <div className="flex flex-col gap-4 max-w-sm w-full">
                        {showIdHelp && (
                            <HelpNote title="ğŸ” å¦‚ä½•æŸ¥è©¢ Google Client ID?" onClose={() => setShowIdHelp(false)}>
                                <p>1. é€²å…¥ <a href="https://console.cloud.google.com/apis/credentials" target="_blank" className="text-blue-600 underline">GCP æ†‘è­‰é é¢</a>ã€‚</p>
                                <p>2. é»æ“Šã€Œ+ å»ºç«‹æ†‘è­‰ã€é¸æ“‡ã€ŒOAuth ç”¨æˆ¶ç«¯ IDã€ã€‚</p>
                                <p>3. æ‡‰ç”¨ç¨‹å¼é¡å‹é¸ã€Œç¶²é æ‡‰ç”¨ç¨‹å¼ã€ã€‚</p>
                                <p>4. å»ºç«‹å¾Œï¼Œé»é¸ç”¨æˆ¶ç«¯IDçš„è¤‡è£½éµè²¼å…¥ (<code>.apps.googleusercontent.com</code> çµå°¾çš„æ–‡å­—)ã€‚</p>
                            </HelpNote>
                        )}
                        
                        {showOriginHelp && (
                            <HelpNote title="âš ï¸ é‡åˆ° 403 éŒ¯èª¤ / æˆæ¬Šå¤±æ•—?" onClose={() => setShowOriginHelp(false)}>
                                <p>1. åœ¨ GCP æ†‘è­‰é é¢ï¼Œé»æ“Šæ‚¨çš„ Client ID ç·¨è¼¯æŒ‰éˆ• (<svg className="inline-block w-3 h-3 text-gray-600 mb-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>)ã€‚</p>
                                <p>2. æ‰¾åˆ° <strong>ã€Œå·²æˆæ¬Šçš„ JavaScript ä¾†æºã€</strong>ã€‚</p>
                                <p>3. é»æ“Šã€Œæ–°å¢ URIã€ã€‚</p>
                                <p>4. é»é¸å·¦å´è—è‰²æ¡†æ¡†å…§çš„è¤‡è£½æŒ‰éˆ•ï¼Œä¸¦è²¼ä¸Šç¶²å€ã€‚</p>
                                <p>5. <strong>å„²å­˜</strong> (éœ€ç­‰å¾…ç´„ 5 åˆ†é˜ç”Ÿæ•ˆ)ã€‚</p>
                            </HelpNote>
                        )}
                    </div>
                </div>
            );

            return (
                <div className="flex flex-col h-screen overflow-hidden">
                    <header className="bg-white border-b px-4 py-2 flex justify-between items-center z-20 shadow-sm">
                        <div className="flex items-center gap-2 font-bold text-lg text-gray-700"><i className="fas fa-file-powerpoint text-yellow-500"></i> OCR Slide Editor</div>
                        <div className="flex items-center gap-3">
                            {isProcessing && <div className="loader w-5 h-5"></div>}
                            <span className="text-sm text-gray-500">{statusMsg}</span>
                            {!accessToken ? <button onClick={handleLogin} className="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700">ç™»å…¥</button> : 
                            <div className="flex items-center gap-2">
                                {userProfile && <img src={userProfile.picture} className="w-8 h-8 rounded-full border" title={`å·²ç™»å…¥: ${userProfile.name}`}/>}
                                <button onClick={exportToSlides} className="bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600 shadow-sm">åŒ¯å‡º PPT</button>
                                <button onClick={clearConfig} className="text-gray-400 hover:text-red-500" title="ç™»å‡ºä¸¦é‡è¨­"><i className="fas fa-sign-out-alt"></i></button>
                            </div>}
                        </div>
                    </header>

                    <div className="bg-white border-b px-4 py-2 flex items-center gap-4 text-sm shadow-sm z-10">
                        <label className="cursor-pointer hover:bg-gray-100 px-2 py-1 rounded border"><i className="fas fa-upload mr-1"></i> ä¸Šå‚³<input type="file" multiple accept=".pdf,image/*" className="hidden" onChange={handleFileUpload} /></label>
                        <button onClick={runOCR} disabled={!currentSlide || isProcessing} className="hover:bg-purple-50 text-purple-700 px-2 py-1 rounded border disabled:opacity-50"><i className="fas fa-magic mr-1"></i> OCR æ™ºæ…§å»å­—è½‰æ›</button>
                        <div className="ml-auto flex items-center gap-2">
                            <button onClick={() => setScale(s => Math.max(0.1, s - 0.1))} className="w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded">-</button>
                            <span>{Math.round(scale * 100)}%</span>
                            <button onClick={() => setScale(s => Math.min(3, s + 0.1))} className="w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded">+</button>
                        </div>
                    </div>

                    <div className="flex flex-1 overflow-hidden relative">
                        <div className="w-48 bg-gray-50 border-r flex-shrink-0 overflow-y-auto p-2 flex flex-col gap-2 z-10">
                            {slides.map((s, idx) => (
                                <div key={s.id} onClick={() => setCurrentSlideIndex(idx)} className={`slide-preview cursor-pointer bg-white border-2 rounded p-1 ${currentSlideIndex === idx ? 'active' : 'border-transparent'}`}>
                                    <img src={s.image} className="w-full h-auto object-contain" />
                                    <div className="text-center text-xs text-gray-500 mt-1">{idx + 1}</div>
                                </div>
                            ))}
                        </div>

                        <div className="flex-1 bg-gray-200 overflow-auto flex justify-center p-10" ref={canvasContainerRef}>
                            {currentSlide ? (
                                <div style={{ width: currentSlide.width * scale, height: currentSlide.height * scale, flexShrink: 0 }}>
                                    <div className="editor-canvas" style={{ width: currentSlide.width, height: currentSlide.height, transform: `scale(${scale})`, transformOrigin: 'top left' }}>
                                        <img src={currentSlide.image} className="absolute inset-0 w-full h-full pointer-events-none" />
                                        {currentSlide.elements.map(el => (
                                            <EditableBlock 
                                                key={el.id} 
                                                el={el} 
                                                isSelected={selectedElementId === el.id} 
                                                onSelect={setSelectedElementId} 
                                                onUpdate={updateElement} 
                                            />
                                        ))}
                                    </div>
                                </div>
                            ) : <div className="m-auto text-gray-400 text-center"><i className="fas fa-image text-4xl mb-2"></i><br/>è«‹ä¸Šå‚³æ–‡ä»¶</div>}
                        </div>

                        {selectedElementId && (
                            <div className="property-panel p-4 flex flex-col gap-3" onMouseDown={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center border-b pb-2 mb-1">
                                    <h3 className="font-bold text-gray-700">æ–‡å­—æ¨£å¼</h3>
                                    <button onClick={deleteElement} className="text-red-500 hover:bg-red-50 px-2 py-1 rounded text-xs"><i className="fas fa-trash-alt"></i> åˆªé™¤</button>
                                </div>
                                {(() => {
                                    const el = currentSlide.elements.find(e => e.id === selectedElementId);
                                    if (!el) return null;
                                    return (
                                        <>
                                            <div className="grid grid-cols-2 gap-2">
                                                <div>
                                                    <label className="text-xs text-gray-500">å­—å‹å¤§å°</label>
                                                    <input type="number" value={Math.round(el.fontSize)} onChange={(e) => updateElement(el.id, { fontSize: parseInt(e.target.value) })} className="w-full border rounded p-1" />
                                                </div>
                                                <div>
                                                    <label className="text-xs text-gray-500">é¡è‰²</label>
                                                    <input type="color" value={el.color} onChange={(e) => updateElement(el.id, { color: e.target.value })} className="w-full h-8 cursor-pointer border rounded" />
                                                </div>
                                            </div>
                                            <div>
                                                <label className="text-xs text-gray-500 block mb-1">èƒŒæ™¯è‰²</label>
                                                <div className="flex gap-2">
                                                    <input type="color" value={el.backgroundColor || '#ffffff'} onChange={(e) => updateElement(el.id, { backgroundColor: e.target.value })} className="flex-1 h-8 cursor-pointer border rounded" />
                                                    <button onClick={() => updateElement(el.id, { backgroundColor: 'transparent' })} className="text-xs bg-gray-100 px-2 rounded border">é€æ˜</button>
                                                </div>
                                            </div>
                                            <div className="flex items-center gap-2 mt-1">
                                                <input type="checkbox" checked={el.isVertical || false} onChange={(e) => updateElement(el.id, { isVertical: e.target.checked })} />
                                                <label className="text-xs text-gray-700">ç›´æ›¸æ¨¡å¼ (Vertical)</label>
                                            </div>
                                            <div>
                                                <label className="text-xs text-gray-500">å­—å‹</label>
                                                <select value={el.fontFamily} onChange={(e) => updateElement(el.id, { fontFamily: e.target.value })} className="w-full border rounded p-1 text-sm">
                                                    <option value="Noto Sans TC">Noto Sans TC</option>
                                                    <option value="Arial">Arial</option>
                                                    <option value="Times New Roman">Times New Roman</option>
                                                    <option value="Microsoft JhengHei">å¾®è»Ÿæ­£é»‘é«”</option>
                                                </select>
                                            </div>
                                        </>
                                    );
                                })()}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>