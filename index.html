<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智慧 PDF/OCR 簡報編輯器 (Inpainting Mode)</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <!-- Google Identity Services -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #e5e7eb; user-select: none; }
        
        .slide-preview { transition: all 0.2s; }
        .slide-preview:hover { border-color: #3b82f6; }
        .slide-preview.active { border-color: #2563eb; ring: 2px solid #2563eb; }
        
        .editor-canvas {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            background-color: white;
            position: relative;
            overflow: hidden;
        }

        .editable-box {
            position: absolute;
            outline: none;
            overflow: hidden;
            white-space: pre-wrap;
            z-index: 10;
            padding: 2px;
            line-height: 1.2;
            cursor: text;
            border: 1px solid transparent; 
            box-sizing: border-box;
            transition: border-color 0.1s;
        }
        
        .editable-box:hover {
            border: 1px solid #3b82f6;
            z-index: 15;
        }
        
        .editable-box.selected {
            border: 2px solid #2563eb; 
            z-index: 20;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .editable-box.vertical {
            writing-mode: vertical-rl;
            text-orientation: upright;
        }
        
        .property-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 260px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            z-index: 50;
            animation: slideIn 0.2s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/presentations https://www.googleapis.com/auth/cloud-vision';

        // --- 進階演算法: 雙線性插值修復 (Inpainting) ---
        // 這是模擬「浮水印去除」的關鍵函式
        const smartInpaint = (ctx, x, y, w, h) => {
            try {
                // 向外擴展 2px 取樣背景
                const margin = 2;
                const sx = Math.max(0, Math.floor(x - margin));
                const sy = Math.max(0, Math.floor(y - margin));
                const sw = Math.ceil(w + margin * 2);
                const sh = Math.ceil(h + margin * 2);

                // 取得該區域的像素資料
                const imgData = ctx.getImageData(sx, sy, sw, sh);
                const data = imgData.data;
                const width = sw;
                const height = sh;

                // 針對區域內的每一個像素進行修補
                for (let j = 0; j < height; j++) {
                    for (let i = 0; i < width; i++) {
                        // 只處理「內部」的像素 (即原本文字所在的位置)
                        // 邊緣像素保持原樣，作為取樣來源
                        if (i > margin && i < width - margin && j > margin && j < height - margin) {
                            
                            const index = (j * width + i) * 4;
                            
                            // 取得上下左右四個邊界對應點的像素索引
                            const topIdx = (0 * width + i) * 4;
                            const bottomIdx = ((height - 1) * width + i) * 4;
                            const leftIdx = (j * width + 0) * 4;
                            const rightIdx = (j * width + (width - 1)) * 4;

                            // 計算權重 (線性插值)
                            const yRatio = j / height;
                            const xRatio = i / width;

                            // R 通道混合
                            const rH = data[topIdx] * (1 - yRatio) + data[bottomIdx] * yRatio; // 垂直方向的漸層預測
                            const rV = data[leftIdx] * (1 - xRatio) + data[rightIdx] * xRatio; // 水平方向的漸層預測
                            data[index] = (rH + rV) / 2; // 取平均

                            // G 通道混合
                            const gH = data[topIdx+1] * (1 - yRatio) + data[bottomIdx+1] * yRatio;
                            const gV = data[leftIdx+1] * (1 - xRatio) + data[rightIdx+1] * xRatio;
                            data[index+1] = (gH + gV) / 2;

                            // B 通道混合
                            const bH = data[topIdx+2] * (1 - yRatio) + data[bottomIdx+2] * yRatio;
                            const bV = data[leftIdx+2] * (1 - xRatio) + data[rightIdx+2] * xRatio;
                            data[index+2] = (bH + bV) / 2;

                            // Alpha 通道 (不透明)
                            data[index+3] = 255; 
                        }
                    }
                }
                
                // 將修復後的像素放回畫布
                ctx.putImageData(imgData, sx, sy);
            } catch (e) {
                console.error("Inpainting failed", e);
                // Fallback: 簡單填白
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y, w, h);
            }
        };

        const EditableBlock = React.memo(({ el, isSelected, onUpdate, onSelect }) => {
            const contentRef = useRef(null);

            useEffect(() => {
                if (contentRef.current && contentRef.current.innerText !== el.text) {
                    if (document.activeElement !== contentRef.current) {
                        contentRef.current.innerText = el.text;
                    }
                }
            }, [el.text]);

            const handleInput = (e) => {
                const newText = e.target.innerText;
                onUpdate(el.id, { text: newText });
            };

            const handleMouseDown = (e) => {
                e.stopPropagation(); 
                onSelect(el.id);
            };

            return (
                <div
                    ref={contentRef}
                    className={`editable-box ${isSelected ? 'selected' : ''} ${el.isVertical ? 'vertical' : ''}`}
                    contentEditable
                    suppressContentEditableWarning
                    style={{
                        left: `${el.x}px`,
                        top: `${el.y}px`,
                        width: `${el.width}px`,
                        height: `${el.height}px`,
                        fontSize: `${el.fontSize}px`,
                        color: el.color,
                        fontFamily: el.fontFamily,
                        backgroundColor: el.backgroundColor || 'transparent', 
                        textAlign: 'left'
                    }}
                    onInput={handleInput}
                    onMouseDown={handleMouseDown}
                >
                    {el.text}
                </div>
            );
        });

        function App() {
            const [config, setConfig] = useState({ clientId: '', apiKey: '' });
            const [rememberConfig, setRememberConfig] = useState(true);
            const [isConfigured, setIsConfigured] = useState(false);
            const [tokenClient, setTokenClient] = useState(null);
            const [accessToken, setAccessToken] = useState(null);
            const [userProfile, setUserProfile] = useState(null);
            const [envError, setEnvError] = useState(null);
            const [currentOrigin, setCurrentOrigin] = useState('');
            const [isGithub, setIsGithub] = useState(false);
            const [slides, setSlides] = useState([]);
            const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
            const [scale, setScale] = useState(0.5);
            const [isProcessing, setIsProcessing] = useState(false);
            const [statusMsg, setStatusMsg] = useState('');
            const [selectedElementId, setSelectedElementId] = useState(null);
            const canvasContainerRef = useRef(null);

            useEffect(() => {
                const protocol = window.location.protocol;
                const origin = window.location.origin;
                setCurrentOrigin(origin);
                if (protocol === 'file:') setEnvError('file_protocol');
                if (window.location.hostname.endsWith('github.io')) setIsGithub(true);

                const savedConfig = localStorage.getItem('slide_ocr_config');
                if (savedConfig) {
                    try {
                        const parsed = JSON.parse(savedConfig);
                        if (parsed.clientId) {
                            setConfig(parsed);
                            setIsConfigured(true);
                            initializeGoogle(parsed.clientId, parsed.apiKey);
                        }
                    } catch (e) { console.error(e); }
                }

                const handleGlobalClick = (e) => {
                    if (e.target.closest('.editable-box') || e.target.closest('.property-panel')) return;
                    setSelectedElementId(null);
                };
                window.addEventListener('mousedown', handleGlobalClick);
                return () => window.removeEventListener('mousedown', handleGlobalClick);
            }, []);

            const initializeGoogle = (clientId, apiKey) => {
                if (window.location.protocol === 'file:') return null;
                if (window.google && window.google.accounts) {
                    const client = google.accounts.oauth2.initTokenClient({
                        client_id: clientId, scope: SCOPES,
                        callback: (tokenResponse) => {
                            if (tokenResponse.access_token) {
                                setAccessToken(tokenResponse.access_token);
                                fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                                    headers: { Authorization: `Bearer ${tokenResponse.access_token}` }
                                }).then(res => res.json()).then(data => setUserProfile(data));
                            }
                        },
                        error_callback: (err) => alert("登入錯誤: " + JSON.stringify(err))
                    });
                    setTokenClient(client);
                }
                if (window.gapi) {
                    gapi.load('client', () => {
                        gapi.client.init({ apiKey: apiKey || undefined, discoveryDocs: ['https://slides.googleapis.com/$discovery/rest?version=v1', 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'] });
                    });
                }
            };

            const handleConfigSubmit = (e) => {
                e.preventDefault();
                if (envError) return;
                if (config.clientId) {
                    if (rememberConfig) localStorage.setItem('slide_ocr_config', JSON.stringify(config));
                    else localStorage.removeItem('slide_ocr_config');
                    setIsConfigured(true);
                    setTimeout(() => initializeGoogle(config.clientId, config.apiKey), 500);
                }
            };

            const clearConfig = () => {
                if (window.confirm("確定重設?")) {
                    localStorage.removeItem('slide_ocr_config');
                    window.location.reload();
                }
            };

            const handleLogin = () => {
                if (tokenClient) tokenClient.requestAccessToken();
                else {
                    const client = initializeGoogle(config.clientId, config.apiKey);
                    if(client) client.requestAccessToken();
                }
            };

            const handleFileUpload = async (e) => {
                const files = Array.from(e.target.files);
                if (!files.length) return;
                setIsProcessing(true);
                let newSlides = [];
                for (const file of files) {
                    if (file.type === 'application/pdf') {
                        const ab = await file.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument(ab).promise;
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const vp = page.getViewport({ scale: 2.0 });
                            const cvs = document.createElement('canvas');
                            cvs.width = vp.width; cvs.height = vp.height;
                            await page.render({ canvasContext: cvs.getContext('2d'), viewport: vp }).promise;
                            newSlides.push({ id: crypto.randomUUID(), image: cvs.toDataURL('image/jpeg', 0.8), width: vp.width, height: vp.height, elements: [] });
                        }
                    } else if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        const imgData = await new Promise(r => { reader.onload = ev => r(ev.target.result); reader.readAsDataURL(file); });
                        const img = new Image();
                        await new Promise(r => { img.onload = r; img.src = imgData; });
                        newSlides.push({ id: crypto.randomUUID(), image: imgData, width: img.width, height: img.height, elements: [] });
                    }
                }
                setSlides(prev => [...prev, ...newSlides]);
                setIsProcessing(false);
            };

            const runOCR = async () => {
                if (!slides.length || !accessToken) return alert("請先登入並上傳檔案");
                const slide = slides[currentSlideIndex];
                if (slide.elements.length && !confirm("重新識別將會重置此頁面，確定嗎？")) return;
                
                setIsProcessing(true);
                setStatusMsg('OCR 分析中...');
                
                try {
                    const res = await fetch(`https://vision.googleapis.com/v1/images:annotate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
                        body: JSON.stringify({ requests: [{ image: { content: slide.image.split(',')[1] }, features: [{ type: 'DOCUMENT_TEXT_DETECTION' }] }] })
                    });
                    const result = await res.json();
                    if (result.error) throw result.error;

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = slide.width;
                    tempCanvas.height = slide.height;
                    const ctx = tempCanvas.getContext('2d');
                    const img = new Image();
                    await new Promise(r => { img.onload = r; img.src = slide.image; });
                    ctx.drawImage(img, 0, 0);

                    const newElements = [];
                    const annotation = result.responses?.[0]?.fullTextAnnotation;
                    
                    if (annotation) {
                        setStatusMsg('正在執行浮水印去除與文字填補...');
                        
                        annotation.pages[0].blocks.forEach(block => {
                            block.paragraphs.forEach(para => {
                                const vertices = para.boundingBox.vertices;
                                const text = para.words.map(w => w.symbols.map(s => s.text).join('')).join('');
                                
                                const x = vertices[0].x || 0;
                                const y = vertices[0].y || 0;
                                const w = (vertices[2].x || x) - x;
                                const h = (vertices[2].y || y) - y;

                                if (w > 0 && h > 0) {
                                    // 1. 執行 Inpainting (浮水印去除)
                                    // 這會直接修改底圖，把文字「擦掉」
                                    smartInpaint(ctx, x, y, w, h);

                                    const isVertical = (h > w * 1.5) && /[^\x00-\x7F]/.test(text);

                                    newElements.push({
                                        id: crypto.randomUUID(),
                                        text: text,
                                        x: x, y: y, width: w, height: h,
                                        fontSize: Math.round(isVertical ? w * 0.7 : h * 0.8),
                                        color: '#000000',
                                        fontFamily: 'Noto Sans TC',
                                        // 2. 文字框背景設為透明 (因為底圖已經擦乾淨了)
                                        backgroundColor: 'transparent',
                                        isVertical: isVertical
                                    });
                                }
                            });
                        });
                    }
                    
                    const updated = [...slides];
                    // 更新為「去背後」的圖片
                    updated[currentSlideIndex].image = tempCanvas.toDataURL('image/jpeg', 0.9);
                    updated[currentSlideIndex].elements = newElements;
                    setSlides(updated);

                } catch (err) { alert("OCR 失敗: " + (err.message || JSON.stringify(err))); }
                setIsProcessing(false); setStatusMsg('');
            };

            const updateElement = useCallback((id, changes) => {
                setSlides(prev => {
                    const newSlides = [...prev];
                    const elements = newSlides[currentSlideIndex].elements;
                    const idx = elements.findIndex(e => e.id === id);
                    if (idx !== -1) {
                        elements[idx] = { ...elements[idx], ...changes };
                    }
                    return newSlides;
                });
            }, [currentSlideIndex]);

            const deleteElement = () => {
                if (!selectedElementId) return;
                setSlides(prev => {
                    const newSlides = [...prev];
                    newSlides[currentSlideIndex].elements = newSlides[currentSlideIndex].elements.filter(e => e.id !== selectedElementId);
                    return newSlides;
                });
                setSelectedElementId(null);
            };

            const exportToSlides = async () => {
                if (!accessToken) return alert("請先登入");
                setIsProcessing(true); setStatusMsg('建立簡報中...');
                try {
                    const createRes = await gapi.client.request({ path: 'https://slides.googleapis.com/v1/presentations', method: 'POST', body: { title: 'OCR Export' } });
                    const presentationId = createRes.result.presentationId;
                    let requests = [];

                    for (let i = 0; i < slides.length; i++) {
                        const s = slides[i];
                        const pageId = `slide_${i}_${Date.now()}`;
                        requests.push({ createSlide: { objectId: pageId, slideLayoutReference: { predefinedLayout: 'BLANK' } } });
                        
                        const boundary = '-------314159265358979323846';
                        const body = `\r\n--${boundary}\r\nContent-Type: application/json\r\n\r\n${JSON.stringify({name: 'bg.jpg', parents:['root']})}\r\n--${boundary}\r\nContent-Type: image/jpeg\r\nContent-Transfer-Encoding: base64\r\n\r\n${s.image.split(',')[1]}\r\n--${boundary}--`;
                        const upRes = await gapi.client.request({ path: '/upload/drive/v3/files?uploadType=multipart', method: 'POST', headers: { 'Content-Type': `multipart/related; boundary="${boundary}"` }, body: body });
                        const fileId = upRes.result.id;
                        await gapi.client.request({ path: `/drive/v3/files/${fileId}/permissions`, method: 'POST', body: { role: 'reader', type: 'anyone' } });

                        requests.push({ updatePageProperties: { objectId: pageId, pageProperties: { pageBackgroundFill: { stretchedPictureFill: { contentUrl: `https://drive.google.com/uc?export=download&id=${fileId}` } } }, fields: 'pageBackgroundFill' } });

                        const pxToPt = 0.75;
                        s.elements.forEach(el => {
                            const id = `txt_${el.id}`;
                            requests.push({ 
                                createShape: { 
                                    objectId: id, 
                                    shapeType: 'TEXT_BOX', 
                                    elementProperties: { 
                                        pageObjectId: pageId, 
                                        size: { width: { magnitude: el.width * pxToPt, unit: 'PT' }, height: { magnitude: el.height * pxToPt, unit: 'PT' } }, 
                                        transform: { scaleX: 1, scaleY: 1, translateX: el.x * pxToPt, translateY: el.y * pxToPt, unit: 'PT' } 
                                    } 
                                } 
                            });
                            requests.push({ insertText: { objectId: id, text: el.text } });
                            
                            const hex = el.color;
                            const r = parseInt(hex.slice(1,3),16)/255;
                            const g = parseInt(hex.slice(3,5),16)/255;
                            const b = parseInt(hex.slice(5,7),16)/255;

                            requests.push({ 
                                updateTextStyle: { 
                                    objectId: id, 
                                    style: { 
                                        fontSize: { magnitude: el.fontSize * pxToPt, unit: 'PT' }, 
                                        foregroundColor: { opaqueColor: { rgbColor: { red: r, green: g, blue: b } } }, 
                                        fontFamily: el.fontFamily 
                                    }, 
                                    fields: 'fontSize,foregroundColor,fontFamily' 
                                } 
                            });
                        });
                    }
                    await gapi.client.request({ path: `https://slides.googleapis.com/v1/presentations/${presentationId}:batchUpdate`, method: 'POST', body: { requests } });
                    window.open(`https://docs.google.com/presentation/d/${presentationId}/edit`, '_blank');
                } catch (e) { alert("匯出失敗: " + (e.result?.error?.message || e.message)); }
                setIsProcessing(false); setStatusMsg('');
            };

            const currentSlide = slides[currentSlideIndex];

            if (!isConfigured) return (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="bg-white p-8 rounded shadow-lg max-w-md w-full">
                        <h1 className="text-2xl font-bold mb-4 text-blue-600">設定 Google Cloud</h1>
                        {envError && <div className="text-red-600 bg-red-50 p-3 rounded mb-4 text-sm font-bold">請勿直接開啟 HTML (file://)，請使用 Local Server。</div>}
                        {!envError && <div className="bg-blue-50 p-3 rounded mb-4 text-xs text-blue-800">請將此網址加入 GCP Console 的「已授權來源」：<br/><code className="select-all bg-white p-1 rounded border">{currentOrigin}</code></div>}
                        <form onSubmit={handleConfigSubmit}>
                            <input required className="w-full border p-2 rounded mb-4" value={config.clientId} onChange={e=>setConfig({...config, clientId: e.target.value})} placeholder="Client ID" />
                            <input className="w-full border p-2 rounded mb-4" value={config.apiKey} onChange={e=>setConfig({...config, apiKey: e.target.value})} placeholder="API Key (選填)" />
                            <label className="flex items-center mb-6"><input type="checkbox" checked={rememberConfig} onChange={e=>setRememberConfig(e.target.checked)} className="mr-2"/> 記住設定</label>
                            <button disabled={!!envError} className="w-full bg-blue-600 text-white p-2 rounded font-bold hover:bg-blue-700">儲存並登入</button>
                        </form>
                    </div>
                </div>
            );

            return (
                <div className="flex flex-col h-screen overflow-hidden">
                    <header className="bg-white border-b px-4 py-2 flex justify-between items-center z-20 shadow-sm">
                        <div className="flex items-center gap-2 font-bold text-lg text-gray-700"><i className="fas fa-file-powerpoint text-yellow-500"></i> OCR Slide Editor</div>
                        <div className="flex items-center gap-3">
                            {isProcessing && <div className="loader w-5 h-5"></div>}
                            <span className="text-sm text-gray-500">{statusMsg}</span>
                            {!accessToken ? <button onClick={handleLogin} className="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700">登入</button> : 
                            <div className="flex items-center gap-2">
                                {userProfile && <img src={userProfile.picture} className="w-8 h-8 rounded-full border"/>}
                                <button onClick={exportToSlides} className="bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600 shadow-sm">匯出 PPT</button>
                                <button onClick={clearConfig} className="text-gray-400 hover:text-red-500"><i className="fas fa-sign-out-alt"></i></button>
                            </div>}
                        </div>
                    </header>

                    <div className="bg-white border-b px-4 py-2 flex items-center gap-4 text-sm shadow-sm z-10">
                        <label className="cursor-pointer hover:bg-gray-100 px-2 py-1 rounded border"><i className="fas fa-upload mr-1"></i> 上傳<input type="file" multiple accept=".pdf,image/*" className="hidden" onChange={handleFileUpload} /></label>
                        <button onClick={runOCR} disabled={!currentSlide || isProcessing} className="hover:bg-purple-50 text-purple-700 px-2 py-1 rounded border disabled:opacity-50"><i className="fas fa-magic mr-1"></i> OCR 智慧去字轉換</button>
                        <div className="ml-auto flex items-center gap-2">
                            <button onClick={() => setScale(s => Math.max(0.1, s - 0.1))} className="w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded">-</button>
                            <span>{Math.round(scale * 100)}%</span>
                            <button onClick={() => setScale(s => Math.min(3, s + 0.1))} className="w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded">+</button>
                        </div>
                    </div>

                    <div className="flex flex-1 overflow-hidden relative">
                        <div className="w-48 bg-gray-50 border-r flex-shrink-0 overflow-y-auto p-2 flex flex-col gap-2 z-10">
                            {slides.map((s, idx) => (
                                <div key={s.id} onClick={() => setCurrentSlideIndex(idx)} className={`slide-preview cursor-pointer bg-white border-2 rounded p-1 ${currentSlideIndex === idx ? 'active' : 'border-transparent'}`}>
                                    <img src={s.image} className="w-full h-auto object-contain" />
                                    <div className="text-center text-xs text-gray-500 mt-1">{idx + 1}</div>
                                </div>
                            ))}
                        </div>

                        <div className="flex-1 bg-gray-200 overflow-auto flex justify-center p-10" ref={canvasContainerRef}>
                            {currentSlide ? (
                                <div style={{ width: currentSlide.width * scale, height: currentSlide.height * scale, flexShrink: 0 }}>
                                    <div className="editor-canvas" style={{ width: currentSlide.width, height: currentSlide.height, transform: `scale(${scale})`, transformOrigin: 'top left' }}>
                                        <img src={currentSlide.image} className="absolute inset-0 w-full h-full pointer-events-none" />
                                        {currentSlide.elements.map(el => (
                                            <EditableBlock 
                                                key={el.id} 
                                                el={el} 
                                                isSelected={selectedElementId === el.id} 
                                                onSelect={setSelectedElementId} 
                                                onUpdate={updateElement} 
                                            />
                                        ))}
                                    </div>
                                </div>
                            ) : <div className="m-auto text-gray-400 text-center"><i className="fas fa-image text-4xl mb-2"></i><br/>請上傳文件</div>}
                        </div>

                        {selectedElementId && (
                            <div className="property-panel p-4 flex flex-col gap-3" onMouseDown={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center border-b pb-2 mb-1">
                                    <h3 className="font-bold text-gray-700">文字樣式</h3>
                                    <button onClick={deleteElement} className="text-red-500 hover:bg-red-50 px-2 py-1 rounded text-xs"><i className="fas fa-trash-alt"></i> 刪除</button>
                                </div>
                                {(() => {
                                    const el = currentSlide.elements.find(e => e.id === selectedElementId);
                                    if (!el) return null;
                                    return (
                                        <>
                                            <div className="grid grid-cols-2 gap-2">
                                                <div>
                                                    <label className="text-xs text-gray-500">字型大小</label>
                                                    <input type="number" value={Math.round(el.fontSize)} onChange={(e) => updateElement(el.id, { fontSize: parseInt(e.target.value) })} className="w-full border rounded p-1" />
                                                </div>
                                                <div>
                                                    <label className="text-xs text-gray-500">顏色</label>
                                                    <input type="color" value={el.color} onChange={(e) => updateElement(el.id, { color: e.target.value })} className="w-full h-8 cursor-pointer border rounded" />
                                                </div>
                                            </div>
                                            <div>
                                                <label className="text-xs text-gray-500 block mb-1">背景色</label>
                                                <div className="flex gap-2">
                                                    <input type="color" value={el.backgroundColor || '#ffffff'} onChange={(e) => updateElement(el.id, { backgroundColor: e.target.value })} className="flex-1 h-8 cursor-pointer border rounded" />
                                                    <button onClick={() => updateElement(el.id, { backgroundColor: 'transparent' })} className="text-xs bg-gray-100 px-2 rounded border">透明</button>
                                                </div>
                                            </div>
                                            <div className="flex items-center gap-2 mt-1">
                                                <input type="checkbox" checked={el.isVertical || false} onChange={(e) => updateElement(el.id, { isVertical: e.target.checked })} />
                                                <label className="text-xs text-gray-700">直書模式 (Vertical)</label>
                                            </div>
                                            <div>
                                                <label className="text-xs text-gray-500">字型</label>
                                                <select value={el.fontFamily} onChange={(e) => updateElement(el.id, { fontFamily: e.target.value })} className="w-full border rounded p-1 text-sm">
                                                    <option value="Noto Sans TC">Noto Sans TC</option>
                                                    <option value="Arial">Arial</option>
                                                    <option value="Times New Roman">Times New Roman</option>
                                                    <option value="Microsoft JhengHei">微軟正黑體</option>
                                                </select>
                                            </div>
                                        </>
                                    );
                                })()}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>